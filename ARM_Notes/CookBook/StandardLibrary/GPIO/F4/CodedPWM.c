/**
  *****************************************************************************
  * @title   main.c
  * @author  muhittin_kaplan
  * @date    12 Sep 2013
  * @brief   Software Pwm for RC Servos with Stm32f4Discovery
  *******************************************************************************
  */
////// The above comment is automatically generated by CoIDE ///////////////////

#include "stm32f4xx.h"
#include "stm32f4xx_gpio.h"
#include "stm32f4xx_rcc.h"
//#include "stm32f4xx_flash.h"
#include "stm32f4xx_tim.h"
#include "misc.h"


char PWM_Counter=0;

//char DUTY_0=10; //20ms period-1ms duty
//char DUTY_1=20;	//20ms period-2ms duty
//char DUTY_2=10;
char DUTY_0=5; //20ms period-1ms duty
char DUTY_1=10;	//20ms period-2ms duty
char DUTY_2=15;


void GPIO_Config(){
	GPIO_InitTypeDef GPIO_InitStructure;
	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOC,ENABLE);
	GPIO_InitStructure.GPIO_Pin=GPIO_Pin_6 | GPIO_Pin_7 | GPIO_Pin_8;
	GPIO_InitStructure.GPIO_Mode=GPIO_Mode_OUT;
	GPIO_InitStructure.GPIO_OType=GPIO_OType_PP;
	GPIO_InitStructure.GPIO_Speed=GPIO_Speed_100MHz;
	GPIO_InitStructure.GPIO_PuPd=GPIO_PuPd_UP;
	GPIO_Init(GPIOC,&GPIO_InitStructure);

}

void TIM2_Config(){

	TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);

	//TIM_TimeBaseStructure.TIM_Period =8399;
	TIM_TimeBaseStructure.TIM_Period =20;
	TIM_TimeBaseStructure.TIM_Prescaler = 8400;
	TIM_TimeBaseStructure.TIM_ClockDivision = 0;
	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
	TIM_TimeBaseStructure.TIM_RepetitionCounter = 0;
	TIM_TimeBaseInit(TIM2, &TIM_TimeBaseStructure);

	TIM_ClearITPendingBit(TIM2, TIM_IT_Update);
	TIM_ITConfig(TIM2, TIM_IT_Update, ENABLE);

	TIM_Cmd(TIM2, ENABLE);
}

void TIM2_IRQHandler(void){
	/*if (TIM_GetITStatus(TIM2, TIM_IT_Update) != RESET){
		TIM_ClearITPendingBit(TIM2, TIM_IT_Update);
		PWM_Counter++;
		if(PWM_Counter>=DUTY_0)GPIO_ResetBits(GPIOC,GPIO_Pin_6);
		if(PWM_Counter>=DUTY_1)GPIO_ResetBits(GPIOC,GPIO_Pin_7);
		if(PWM_Counter>=DUTY_2)GPIO_ResetBits(GPIOC,GPIO_Pin_8);
		if(PWM_Counter==199){PWM_Counter=0;GPIO_SetBits(GPIOC,GPIO_Pin_All);}
	} */

	if (TIM_GetITStatus(TIM2, TIM_IT_Update) != RESET){
		TIM_ClearITPendingBit(TIM2, TIM_IT_Update);
		PWM_Counter++;
		if(PWM_Counter>=DUTY_0)
			 GPIO_ResetBits(GPIOC,GPIO_Pin_6);
		else
			GPIO_SetBits(GPIOC,GPIO_Pin_6);

		if(PWM_Counter>=DUTY_1)
			GPIO_ResetBits(GPIOC,GPIO_Pin_7);
		else
			GPIO_SetBits(GPIOC,GPIO_Pin_7);

		if(PWM_Counter>=DUTY_2)
			GPIO_ResetBits(GPIOC,GPIO_Pin_8);
		else
			GPIO_SetBits(GPIOC,GPIO_Pin_8);

	//	if(PWM_Counter==199){PWM_Counter=0;GPIO_SetBits(GPIOC,GPIO_Pin_All);}
	}
}

void NVIC_Config(){
	NVIC_InitTypeDef NVIC_InitStructure;


	NVIC_InitStructure.NVIC_IRQChannel = TIM2_IRQn;
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
	NVIC_Init(&NVIC_InitStructure);

}

int main(void){
//	SystemInit();
	GPIO_Config();
	TIM2_Config();
	NVIC_Config();
	while (1){
/*
		int i;
		//DUTY_0=10;
	//	DUTY_0=5;
		for (i = 0; i < 0x00700000; ++i) {

		}
		//DUTY_0=20;
		//DUTY_0=10;

		for (i = 0; i < 0x00700000; ++i) {

				} */
	}
}
