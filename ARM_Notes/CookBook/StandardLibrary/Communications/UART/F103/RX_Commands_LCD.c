
/**
 *****************************************************************************
 * @title   RX_Commands_LCD.c
 * @date    07 June 2016
 * @brief   This UART demo receive commands from the PC (via UART2) and send text
 *          to the PC. Also, there is a monochrome Nokia 5110 LCD connected
 *          that outputs the commands received from the PC.
 *
 *          To know the commands that the program will recognize, see the
 *          char array ** keywords **.
 *
 *          The UART adapter used is an USB FTDI (little orange one). Due to the pins
 *          used by the LCD on the PORT A (where the UART1 pins reside), we used the
 *          UART2 instead,
  *  Connection with the STM32F103C8T6, LCD:
  *                  STM32			Nokia 5110           UART Adapter
  *				    -------------------------------------------------
  *   				  A12 	 -->    LCD_PIN_ENABLE
  *   				  A11 	 -->    LCD_PIN_RESET
  *   				  A10 	 -->    LCD_PIN_COMMAND
  *   				  A9	 -->    LCD_PIN_DATA
  *   				  A8	 -->    LCD_PIN_CLOCK
  *                   A3     						  --> TX
  *                   A2     						  --> RX
  *					 GND     -->    LCD_LIGHT
  *                          -->    GND (LCD)        --> GND (Adapter)
 *******************************************************************************
 */
////// The above comment is automatically generated by CoIDE ///////////////////

/* Includes ------------------------------------------------------------------*/

#include <stdio.h>

#include "stm32f10x_rcc.h"
#include "stm32f10x_gpio.h"]
#include "stm32f10x_usart.h"

#include "misc.h"

#include "stm32_delay.h"
#include "Nokkia5110.h"

#define TRUE 		 1
#define FALSE 		 0

#define NUM 		   10
#define RETURN_KEY	   13
#define UNKNOWN_ENTRY   0


int i,j;
int bytesReceived = 0;
int commandToProcess = 0;
char userEntry[NUM+1] = {'\0'};
unsigned char keywords[4][10] = {"run","start","stop","reset"};

ErrorStatus HSEStartUpStatus;

/* Private function prototypes -----------------------------------------------*/
void GPIO_Configuration(void);
void NVIC_Configuration(void);
void USART_Configuration(void);
void USART2_IRQHandler(void);
void UARTSend(const unsigned char *pucBuffer, unsigned long ulCount);
void resetUserEntry(void);
int isEndOfEntry(uint16_t nextChar);




/*******************************************************************************
 * Function Name  : GPIO_Configuration
 * Description    : Configures the different GPIO ports.
 * Input          : None
 * Output         : None
 * Return         : None
 *******************************************************************************/
void GPIO_Configuration(void)
{
	GPIO_InitTypeDef GPIO_InitStructure;

	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);

	/* Configure USART1 Tx (PA.09) as alternate function push-pull */
	//  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9 |GPIO_Pin_10;
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2 ; //|GPIO_Pin_3
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_Init(GPIOA, &GPIO_InitStructure);

	//GPIO_Pin_3 Configure USART1 Rx (PA.10) as input floating
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
	GPIO_Init(GPIOA, &GPIO_InitStructure);

	GPIO_InitStructure.GPIO_Pin = LCD_PIN_ENABLE | LCD_PIN_RESET | LCD_PIN_COMMAND | LCD_PIN_DATA | LCD_PIN_CLOCK;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_10MHz;
	GPIO_Init(GPIOA, &GPIO_InitStructure);

	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC, ENABLE);  //Start Clock on Port C - Green Led

	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_Out_PP;
	GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_13;
	GPIO_Init(GPIOC, &GPIO_InitStructure);

	GPIO_SetBits(GPIOC, GPIO_Pin_13 );
}

/*******************************************************************************
 * Function Name  : USART_Configuration
 * Description    : Configures the USART1.
 * Input          : None
 * Output         : None
 * Return         : None
 *******************************************************************************/
void USART_Configuration(void)
{
	USART_InitTypeDef USART_InitStructure;

	RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE);

	USART_DeInit(USART2);

	/* USART1 configuration ------------------------------------------------------*/
	/* USART1 configured as follow:
        - BaudRate = 115200 baud
        - Word Length = 8 Bits
        - One Stop Bit
        - No parity
        - Hardware flow control disabled (RTS and CTS signals)
        - Receive and transmit enabled
        - USART Clock disabled
        - USART CPOL: Clock is active low
        - USART CPHA: Data is captured on the middle
        - USART LastBit: The clock pulse of the last data bit is not output to
                         the SCLK pin
	 */
	USART_InitStructure.USART_BaudRate = 115200;
	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
	USART_InitStructure.USART_StopBits = USART_StopBits_1;
	USART_InitStructure.USART_Parity = USART_Parity_No;
	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;

	USART_Init(USART2, &USART_InitStructure);
	USART_Cmd(USART2, ENABLE);  	/* Enable USART2 */

	USART_ITConfig(USART2, USART_IT_RXNE , ENABLE);
	//  USART_ITConfig(USART1, USART_IT_RXNE | USART_FLAG_TC | USART_FLAG_TXE, ENABLE);

//	NVIC_EnableIRQ(USART2_IRQn);
}

/**
 * @brief  Configures the nested vectored interrupt controller.
 * @param  None
 * @retval None
 */
void NVIC_Configuration(void)
{
	NVIC_InitTypeDef NVIC_InitStructure;

	/* Enable the USARTx Interrupt */
	NVIC_InitStructure.NVIC_IRQChannel = USART2_IRQn;

	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
	NVIC_Init(&NVIC_InitStructure);

	NVIC_EnableIRQ(USART2_IRQn);
}



void blinkLed()
{
	GPIO_ResetBits(GPIOC, GPIO_Pin_13);
	Delay_ms(100);
	Lcd_clear_screen();
	GPIO_SetBits(GPIOC, GPIO_Pin_13 );
	//Delay_ms(150);
}

/******************************************************************************/
/*            STM32F10x Peripherals Interrupt Handlers                        */
/******************************************************************************/

/**
 * @brief  This function handles USART2 global interrupt request.
 * @param  None
 * @retval None
 */
void USART2_IRQHandler(void)
{
	if(USART_GetITStatus(USART2, USART_IT_RXNE) != RESET)
	{
		i = USART_ReceiveData(USART2);
		bytesReceived = TRUE;

		if  (i == RETURN_KEY)
			commandToProcess = TRUE;
		 else if(j == NUM)
			resetUserEntry();
		 else
		 {
			userEntry[j++] = i;
			userEntry[j] = '\0';
		 }
	}
	else if ((USART2->SR & USART_FLAG_TC) != (u16)RESET) // Transmit Completed Flag
	{
	}
	else if ((USART2->SR & USART_FLAG_TXE) != (u16)RESET) // Transmit empty Flag
	{
	}
}


int isEndOfEntry(uint16_t nextChar)
{
	if(j == NUM)
		return 1;
	else if  (nextChar == 13)
		return 1;
	else
		return 0;
}

void resetUserEntry(void)
{
	memset(userEntry, 0, NUM+1);
	j = 0;

}


/*******************************************************************************
 * Function Name  : sendToPC
 * Description    : This method keeps send 250 bytes to the PC at the time, in
 *                  infinite loop, and make the Led flash on each chunk sent on
 *                  the UART interface.
 *******************************************************************************/
void sendToPC()
{
	int MAX_VALUE = 250;
	//Only 250 bytes used to the test.
	unsigned char menu[MAX_VALUE];
	memset(menu, 0, MAX_VALUE);

	for (unsigned char i=0;i<MAX_VALUE;i++)
		menu[i] = i;


	while(1)
	{
		GPIO_ResetBits(GPIOC, GPIO_Pin_13 );
		UARTSend(menu, sizeof(menu));
		GPIO_SetBits(GPIOC, GPIO_Pin_13 );
		Delay_ms(2000);
	}
}

/* Private functions ---------------------------------------------------------*/

/*******************************************************************************
 * Function Name  : usart_rxtx
 * Description    : Print "Welcome to CooCox!"  on Hyperterminal via USART1.
 * Input          : None
 * Output         : None
 * Return         : None
 *******************************************************************************/
int main(void)
{
	unsigned char menu[] = " Waiting for bytes...\n\r";
	unsigned char outputMessage[50];


	memset(outputMessage,0,sizeof(outputMessage));

	int nextLine = 2;

	/* Configure the GPIOs */
	GPIO_Configuration();

	// Reset LCD & Initialise...
	LcdReset();
	LcdInitalise();


	USART_Configuration();
	NVIC_Configuration();


	Lcd_clear_screen();
	Lcd_print_string(0, 0, "Init done...");

	Lcd_print_string(0, 1, "Sent bytes");
	UARTSend(menu, sizeof(menu));

	while(1)
	{

		if (bytesReceived == TRUE)
		{
			blinkLed();
			bytesReceived = FALSE;
			Lcd_print_string(0, 1, userEntry);

			if (commandToProcess == TRUE)
			{
				int ret = parseUserEntry(userEntry);
				if (ret != UNKNOWN_ENTRY) {
					//Lcd_print_string(0, 3, "Execute!!!");

					strcpy(outputMessage,"Execute!!!\n\r");


//					Lcd_print_string(0, 3, keywords[ret-1]);
//					UARTSend(keywords[ret-1], sizeof(keywords[ret-1]));
					Lcd_print_string(0, 3, outputMessage);
					UARTSend(outputMessage, sizeof(outputMessage));


				}

				resetUserEntry();
				commandToProcess = FALSE;
			}
		}

	}
}

int parseUserEntry(unsigned char entry[])
{

	for (int j=0;j<4;j++)
	{
		if (strcmp(entry, keywords[j]) == 0)
			//The plus one is because the j loop and the array starts at index 0,
			//but if we send back index o (first command in the array of commands),
			//that is going to create a problem because unknow code is also 0
			return (j+1);
	}

	return UNKNOWN_ENTRY;
}

/*******************************************************************************
 * Function Name  : UARTSend
 * Description    : Send a string to the UART.
 * Input          : - pucBuffer: buffers to be printed.
 *                : - ulCount  : buffer's length
 * Output         : None
 * Return         : None
 *******************************************************************************/
void UARTSend(const unsigned char *pucBuffer, unsigned long ulCount)
{
	uint32_t delayCount = 0;    //
	// Loop while there are more characters to send.
	//
	while(ulCount--)
	{
		USART_SendData(USART2, *pucBuffer++);

		/* Loop until the end of transmission */
		while(USART_GetFlagStatus(USART2, USART_FLAG_TC) == RESET)
		{
			delayCount++;
		}
	}

	if (delayCount != 0){
		delayCount = 0;
	}
}


/*******************************************************************************
 * Function Name  : UARTReceive
 * Description    : Receive a string from  the UART.
 * Input          : - pucBuffer: buffers to put received data
 *                : - ulCount  : buffer's length
 * Output         : None
 * Return         : None
 *******************************************************************************/
void UARTReceive(unsigned char *pucBuffer, unsigned long ulCount)
{
	//
	// Loop while there are more characters to send.
	//
	while(ulCount--)
	{

		/* Loop until the end of transmission */
		while(USART_GetFlagStatus(USART2, USART_FLAG_RXNE) == RESET)
		{
		}

		*pucBuffer++ = USART_ReceiveData(USART2);
	}
}


/******************* (C) COPYRIGHT 2007 STMicroelectronics *****END OF FILE****/
