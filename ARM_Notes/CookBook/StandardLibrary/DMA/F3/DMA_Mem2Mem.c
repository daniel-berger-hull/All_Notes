/**
  *****************************************************************************
  * @title   DMA_MemoryToMemory.c
  * @author  CooCox
  * @date    12 Nov 2013
  * @brief   In this example, DMA works in Memory to Memory mode. The source
  *          data in the source buffer has been initialized before this test,
  *           thus it was in FLASH, but the destination data was not and it w
  *          ould be located in RAM. This example has been tested on MCBSTM32
  *           board, STM32F103RBT6 device. To see the information printed out
  *           via USART, make sure that an RS-232 cable has been connected be
  *          tween PC and development board.
  *******************************************************************************
  */
////// The above comment is automatically generated by CoIDE ///////////////////

/**
  ******************************************************************************
  * @file    DMA/DMA_MermoryToMemory/main.c
  * @author  MCD Application Team
  * @version V1.0.0
  * @date    30-October-2010
  * @brief   Main program body
  ******************************************************************************
  * @attention
  *
  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
  *
  * <h2><center>&copy; COPYRIGHT 2010 STMicroelectronics</center></h2>
  ******************************************************************************
  */

/* Includes ------------------------------------------------------------------*/
#include "stdio.h"
#include "stm32f30x_dma.h"
#include "stm32f30x_usart.h"
#include "stm32f30x_gpio.h"
#include "stm32f30x_rcc.h"
#include "stm32f30x_misc.h"



/***************************************************************************//**
 * Global variables, private define and typedef
 ******************************************************************************/
/* Private typedef -----------------------------------------------------------*/
typedef enum {FAILED = 0, PASSED = !FAILED} TestStatus;

/* Private define ------------------------------------------------------------*/
#define BufferSize  32        /* Data size */
uc32 SRC_Const_Buffer[BufferSize] = { 0x01020304, 0x05060708, 0x090A0B0C,
        0x0D0E0F10, 0x11121314, 0x15161718, 0x191A1B1C, 0x1D1E1F20, 0x21222324,
        0x25262728, 0x292A2B2C, 0x2D2E2F30, 0x31323334, 0x35363738, 0x393A3B3C,
        0x3D3E3F40, 0x41424344, 0x45464748, 0x494A4B4C, 0x4D4E4F50, 0x51525354,
        0x55565758, 0x595A5B5C, 0x5D5E5F60, 0x61626364, 0x65666768, 0x696A6B6C,
        0x6D6E6F70, 0x71727374, 0x75767778, 0x797A7B7C, 0x7D7E7F80 }; /* Source data*/
u32 DST_Buffer[BufferSize];           /* Store destination data */
TestStatus TransferStatus;            /* Transmission is OK or not */
u32 *m = (u32 *) DST_Buffer;          /* Start address of destination data */
#define EndAddr DST_Buffer+BufferSize /* End address of destination data */

/***************************************************************************//**
 * Declare function prototypes
 ******************************************************************************/
void RCC_Configuration(void);
void LEDS_Configuration(void);
void NVIC_Configuration(void);
void USART_Configuration(void);
TestStatus Buffercmp(uc32* pBuffer, u32* pBuffer1, u16 BufferLength);

int main(void)
{

	 uint32_t count;
	    /* System Clocks Configuration -------------------------------------------*/
	    RCC_Configuration();

	    /* Leds Configuration -------------------------------------------*/
	    LEDS_Configuration();

	    /* NVIC Configuration ----------------------------------------------------*/
	    NVIC_Configuration();
	    /* USART1 Configuration --------------------------------------------------*/
	    USART_Configuration();

	    /* DMA Channel6 Configuration --------------------------------------------*/
	    DMA_InitTypeDef DMA_InitStructure;
	    DMA_DeInit(DMA1_Channel6);
	    DMA_InitStructure.DMA_PeripheralBaseAddr = (u32) SRC_Const_Buffer;
	    DMA_InitStructure.DMA_MemoryBaseAddr = (u32) DST_Buffer;
	    DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;

	    DMA_InitStructure.DMA_BufferSize = BufferSize;
	    DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Enable;
	    DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
	    DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Word;
	    DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Word;
	    DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;
	    DMA_InitStructure.DMA_Priority = DMA_Priority_High;
	    DMA_InitStructure.DMA_M2M = DMA_M2M_Enable;
	    DMA_Init(DMA1_Channel6, &DMA_InitStructure);

	    GPIO_WriteBit(GPIOE, GPIO_Pin_11, Bit_SET);   // Display that Initialisation is done and successfull

	    /* Enable DMA Channel6 transfer */
	       DMA_Cmd(DMA1_Channel6, ENABLE);
	       /* Wait until transmission done */
	       while(DMA_GetCurrDataCounter(DMA1_Channel6) !=0);

		    GPIO_WriteBit(GPIOE, GPIO_Pin_12, Bit_SET);   // Display that DMA transfer done
		    printf("DMA transmission done!\n\r");

	       /* Check if the transmitted and received data are equal */
	       TransferStatus = Buffercmp(SRC_Const_Buffer, DST_Buffer, BufferSize);
	       /* TransferStatus = PASSED, if the transmitted and received data
	        are the same */
	       /* TransferStatus = FAILED, if the transmitted and received data
	        are different */
	       printf("DST_Buffer address: 0x%x ~ 0x%x\n\r", m, EndAddr);
	       printf("The contents of the SRC_Const_Buffer are:\n\r");
	       for(count = 0; count < BufferSize; count++)
	          {
	              if(count%4 == 0)
	                  printf("\n\r");
	              printf("0x%8x\t", SRC_Const_Buffer[count]);
	          }
	          printf("\n\r The contents of the DST_Buffer are:\n\r");
	          for(count = 0; count < BufferSize; count++)
	          {
	              if(count%4 == 0)
	                  printf("\n\r");
	              printf("0x%8x\t", DST_Buffer[count]);
	          };
	          if(TransferStatus == PASSED)
	          {
	              printf("\n\r>>>>>>>>>>>>DMA test is OK .\r\n");
	              GPIO_WriteBit(GPIOE, GPIO_Pin_15, Bit_SET);   // Display that DMA transfer successfull
	          }
	          else
	          {
	              GPIO_WriteBit(GPIOE, GPIO_Pin_9, Bit_SET);   // Display that DMA transfer Failed!!!
	        	  printf("\n\r>>>>>>>>>>>>DMA test FAILED.\n\r");
	          }

}


/***************************************************************************//**
 * @brief: RCC_Configuration
 *         Configures the different system clocks.
 *******************************************************************************/
void RCC_Configuration(void)
{
    RCC_DeInit ();                    /* RCC system reset(for debug purpose)*/
    RCC_HSEConfig (RCC_HSE_ON);       /* Enable HSE                         */

    /* Wait till HSE is ready */
    while (RCC_GetFlagStatus(RCC_FLAG_HSERDY) == RESET);

    RCC_HCLKConfig   (RCC_SYSCLK_Div1);   /* HCLK   = SYSCLK */
    RCC_PCLK2Config  (RCC_HCLK_Div1);     /* PCLK2  = HCLK  */
    RCC_PCLK1Config  (RCC_HCLK_Div2);     /* PCLK1  = HCLK/2 */

    /* PLLCLK = 8MHz * 9 = 72 MHz */
    RCC_PLLConfig (0x00010000, RCC_PLLMul_9);

    RCC_PLLCmd (ENABLE);                  /* Enable PLL */

    /* Wait till PLL is ready */
    while (RCC_GetFlagStatus(RCC_FLAG_PLLRDY) == RESET);

    /* Select PLL as system clock source */
    RCC_SYSCLKConfig (RCC_SYSCLKSource_PLLCLK);

    /* Wait till PLL is used as system clock source */
    while (RCC_GetSYSCLKSource() != 0x08);

    /* Enable USART1  clock */
    RCC_APB2PeriphClockCmd (RCC_APB2Periph_USART1 , ENABLE);
    /* Enable DMA1 and GPIOA clock */
    RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOA | RCC_AHBPeriph_DMA1, ENABLE);
}


void LEDS_Configuration(void)
{
	GPIO_InitTypeDef gpioStructure;

	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOE, ENABLE);

    gpioStructure.GPIO_Pin =  GPIO_Pin_8 |     //Blue LED top left
    					      GPIO_Pin_9 |     //Red LED top
    					      GPIO_Pin_10 |    //Orange LED top right
    					      GPIO_Pin_11 |    //Green LED right
    					      GPIO_Pin_12 |    //Blue LED bottom right
    					      GPIO_Pin_13 |    //Red LED bottom
    					      GPIO_Pin_14 |   //Orange LED bottom left
    					      GPIO_Pin_15; ;  //Green LED left
    gpioStructure.GPIO_Mode = GPIO_Mode_OUT;
    gpioStructure.GPIO_PuPd = GPIO_PuPd_UP;  //This will pull up the pin, so if we:
    										 // i)  Write a Bit_SET   (value 1) --> LED will Light ON
    										 // ii) Write a Bit_RESET (value 0) --> Turn of the LED

    gpioStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_Init(GPIOE, &gpioStructure);
}


/***************************************************************************//**
 * @brief Configure USART1
 ******************************************************************************/
void USART_Configuration()
{
      GPIO_InitTypeDef  GPIO_InitStructure;
      USART_InitTypeDef USART_InitStructure;

      /* Configure USART1 Rx (PA10) as input floating */
      GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_10;
      GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_IN;
      GPIO_Init(GPIOA, &GPIO_InitStructure);

      /* Configure USART1 Tx (PA9) as alternate function push-pull */
      GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_9;
      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
      GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF;   //GPIO_Mode_AF_PP
      GPIO_Init(GPIOA, &GPIO_InitStructure);

      /* USART1 configured as follow:
            - BaudRate = 115200 baud
            - Word Length = 8 Bits
            - One Stop Bit
            - No parity
            - Hardware flow control disabled (RTS and CTS signals)
            - Receive and transmit enabled
            - USART Clock disabled
            - USART CPOL: Clock is active low
            - USART CPHA: Data is captured on the middle
            - USART LastBit: The clock pulse of the last data bit is not output to
                             the SCLK pin
      */
      USART_InitStructure.USART_BaudRate            = 115200;
      USART_InitStructure.USART_WordLength          = USART_WordLength_8b;
      USART_InitStructure.USART_StopBits            = USART_StopBits_1;
      USART_InitStructure.USART_Parity              = USART_Parity_No ;
      USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
      USART_InitStructure.USART_Mode                = USART_Mode_Rx | USART_Mode_Tx;
      USART_Init(USART1, &USART_InitStructure);
      USART_Cmd(USART1, ENABLE);
}

/***************************************************************************//**
 * @brief : NVIC_Configuration
 *          Configures NVIC and Vector Table base location.
 ******************************************************************************/
void NVIC_Configuration(void)
{
    NVIC_InitTypeDef NVIC_InitStructure;
#ifdef  VECT_TAB_RAM
    /* Set the Vector Table base location at 0x20000000 */
    NVIC_SetVectorTable(NVIC_VectTab_RAM, 0x0);
#else  /* VECT_TAB_FLASH  */
    /* Set the Vector Table base location at 0x08000000 */
    NVIC_SetVectorTable(NVIC_VectTab_FLASH, 0x0);
#endif
    /* Enable DMA1 channel6 IRQ */
    NVIC_InitStructure.NVIC_IRQChannel = DMA1_Channel6_IRQn;
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    NVIC_Init(&NVIC_InitStructure);
}


/***************************************************************************//**
 * @brief    : Compare two buffers.
 * @param[in]  pBuffer  : buffer to be compared
 * @param[in]  PBuffer1 : buffer to be compared
 * @param[in]  BufferLength : buffer's length
 * @return   :
 *      @li PASSED : pBuffer identical to pBuffer1
 *      @li FAILED : pBuffer differs from pBuffer1
 *******************************************************************************/
TestStatus Buffercmp(uc32* pBuffer, u32* pBuffer1, u16 BufferLength)
{
    while (BufferLength--)
    {
        if (*pBuffer != *pBuffer1)
        {
            return FAILED;
        }
        pBuffer++;
        pBuffer1++;
    }
    return PASSED;
}




